// ignore_for_file: always_specify_types
// ignore_for_file: camel_case_types
// ignore_for_file: non_constant_identifier_names

// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
import 'dart:ffi' as ffi;

/// Bindings for `src/flutter_libsparkmobile.h`.
///
/// Regenerate bindings with `flutter pub run ffigen --config ffigen.yaml`.
///
class FlutterLibsparkmobileBindings {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  FlutterLibsparkmobileBindings(ffi.DynamicLibrary dynamicLibrary)
      : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  FlutterLibsparkmobileBindings.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  /// FFI-friendly wrapper for spark::getAddress.
  ffi.Pointer<ffi.Char> getAddress(
    ffi.Pointer<ffi.Char> keyDataHex,
    int index,
    int diversifier,
    int isTestNet,
  ) {
    return _getAddress(
      keyDataHex,
      index,
      diversifier,
      isTestNet,
    );
  }

  late final _getAddressPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Int, ffi.Int, ffi.Int)>>('getAddress');
  late final _getAddress = _getAddressPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>, int, int, int)>();

  /// FFI-friendly wrapper for spark::identifyCoin.
  CIdentifiedCoinData identifyCoin(
    CCoin c_struct,
    ffi.Pointer<ffi.Char> keyDataHex,
    int index,
  ) {
    return _identifyCoin(
      c_struct,
      keyDataHex,
      index,
    );
  }

  late final _identifyCoinPtr = _lookup<
      ffi.NativeFunction<
          CIdentifiedCoinData Function(
              CCoin, ffi.Pointer<ffi.Char>, ffi.Int)>>('identifyCoin');
  late final _identifyCoin = _identifyCoinPtr.asFunction<
      CIdentifiedCoinData Function(CCoin, ffi.Pointer<ffi.Char>, int)>();

  /// FFI-friendly wrapper for spark::createSparkMintRecipients.
  ffi.Pointer<CCRecipient> createSparkMintRecipients(
    int numRecipients,
    ffi.Pointer<PubKeyScript> pubKeyScripts,
    ffi.Pointer<ffi.Uint64> amounts,
    ffi.Pointer<ffi.Char> memo,
    int subtractFee,
  ) {
    return _createSparkMintRecipients(
      numRecipients,
      pubKeyScripts,
      amounts,
      memo,
      subtractFee,
    );
  }

  late final _createSparkMintRecipientsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<CCRecipient> Function(
              ffi.Int,
              ffi.Pointer<PubKeyScript>,
              ffi.Pointer<ffi.Uint64>,
              ffi.Pointer<ffi.Char>,
              ffi.Int)>>('createSparkMintRecipients');
  late final _createSparkMintRecipients =
      _createSparkMintRecipientsPtr.asFunction<
          ffi.Pointer<CCRecipient> Function(int, ffi.Pointer<PubKeyScript>,
              ffi.Pointer<ffi.Uint64>, ffi.Pointer<ffi.Char>, int)>();
}

/// FFI-friendly wrapper for a spark::Coin.
///
/// A Coin is a type, a key, an index, a value, a memo, and a serial context.  We accept these params
/// as a C struct, deriving the key from the keyData and index.
final class CCoin extends ffi.Struct {
  @ffi.Char()
  external int type;

  external ffi.Pointer<ffi.UnsignedChar> k;

  @ffi.Int()
  external int kLength;

  external ffi.Pointer<ffi.Char> keyData;

  @ffi.Int()
  external int index;

  @ffi.Uint64()
  external int v;

  external ffi.Pointer<ffi.UnsignedChar> memo;

  @ffi.Int()
  external int memoLength;

  external ffi.Pointer<ffi.UnsignedChar> serial_context;

  @ffi.Int()
  external int serial_contextLength;
}

/// FFI-friendly wrapper for a spark::IdentifiedCoinData.
///
/// An IdentifiedCoinData is a diversifier, encrypted diversifier, value, nonce, and memo.  We accept
/// these params as a C struct.
final class CIdentifiedCoinData extends ffi.Struct {
  @ffi.Uint64()
  external int i;

  external ffi.Pointer<ffi.UnsignedChar> d;

  @ffi.Int()
  external int dLength;

  @ffi.Uint64()
  external int v;

  external ffi.Pointer<ffi.UnsignedChar> k;

  @ffi.Int()
  external int kLength;

  external ffi.Pointer<ffi.Char> memo;

  @ffi.Int()
  external int memoLength;
}

/// FFI-friendly wrapper for a spark::CRecipient.
///
/// A CRecipient is a CScript, CAmount, and a bool.  We accept a C-style, FFI-friendly CCRecipient
/// struct in order to construct a C++ CRecipient.  A CScript is constructed from a hex string, a
/// CAmount is just a uint64_t, and the bool will be an int.
final class CCRecipient extends ffi.Struct {
  external ffi.Pointer<ffi.UnsignedChar> pubKey;

  @ffi.Int()
  external int pubKeyLength;

  @ffi.Uint64()
  external int cAmount;

  @ffi.Int()
  external int subtractFee;
}

/// FFI-friendly wrapper for a spark::MintedCoinData.
///
/// A MintedCoinData is a struct that contains an Address, a uint64_t value, and a string memo.  We
/// accept these as a CMintedCoinData from the Dart interface, and convert them to a MintedCoinData
/// struct.
final class CMintedCoinData extends ffi.Struct {
  external ffi.Pointer<ffi.Char> address;

  @ffi.Uint64()
  external int value;

  external ffi.Pointer<ffi.Char> memo;
}

final class PubKeyScript extends ffi.Struct {
  external ffi.Pointer<ffi.UnsignedChar> bytes;

  @ffi.Int()
  external int length;
}
